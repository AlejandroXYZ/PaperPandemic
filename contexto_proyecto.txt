ESTE ES EL C√ìDIGO ACTUAL DEL PROYECTO:
========================================

--- INICIO DE ARCHIVO: main.py ---
import sys
import os
from pathlib import Path
from PySide6.QtGui import QGuiApplication
from PySide6.QtQml import QQmlApplicationEngine
from PySide6.QtQuickControls2 import QQuickStyle

# Aseg√∫rate de que el import sea correcto seg√∫n tu estructura de carpetas
from controllers.sird_controller import ControladorSIRD

if __name__ == "__main__":
    os.environ["QT_QUICK_CONTROLS_STYLE"] = "Material"
    os.environ["QT_QUICK_CONTROLS_MATERIAL_THEME"] = "Dark"
    os.environ["QT_QUICK_CONTROLS_MATERIAL_ACCENT"] = "Purple"

    app = QGuiApplication(sys.argv)
    engine = QQmlApplicationEngine()
    
    # Instanciar el Controlador
    controlador = ControladorSIRD()

    # Exponer a QML
    engine.rootContext().setContextProperty("backend", controlador)
    engine.rootContext().setContextProperty("mapa_modelo", controlador.mapa_modelo)
    
    # NOTA: Ya no hace falta setContextProperty("opciones"...) 
    # porque lo hacemos a trav√©s de backend.config
    
    # Rutas
    base_dir = os.path.dirname(os.path.abspath(__file__))
    engine.addImportPath(os.path.join(base_dir, "ui"))
    
    qml_file = Path(__file__).parent / "ui/main.qml"
    engine.load(qml_file)

    if not engine.rootObjects():
        sys.exit(-1)

    sys.exit(app.exec())

--- FIN DE ARCHIVO: main.py ---

--- INICIO DE ARCHIVO: backend/engine.py ---
from backend.sir_model import SIR
from backend.loader import Loader
import numpy as np

class Engine():

    def __init__(self, opciones_instancia):
        self.opt = opciones_instancia    
        self.csv = Loader(self.opt)
                    
        # Intentar crear/conectar DB
        # self.db devuelve True si es NUEVA, False si ya EXIST√çA
        self.db = self.csv.crear_db()
        self.dia_simulacion = 1 
                    
        # --- L√ìGICA DE CARGA SEGURA ---
        if self.db:            
            # CASO A: Partida Nueva (Acabas de borrar la DB o es la primera vez)
            self.dataframe = self.csv.cargar_df()
                        
            # --- FIX: CREAR HISTORIAL VAC√çO ---
            # Antes faltaba esta l√≠nea, por eso fallaba al decir 'object has no attribute historial'
            self.historial = self.csv.historial() 
                        
            self.primer_pais = None 
            
        else:
        # CASO B: Cargar Partida Existente (Guinea sigue viva aqu√≠)
            self.dataframe = self.csv.cargar_db()
            self.historial = self.csv.historial()
                        
            # Recuperar d√≠a guardado
            if not self.historial.empty:
                try: self.dia_simulacion = int(self.historial.iloc[-1]["dia"])
                except: self.dia_simulacion = 1
                    
        # --- L√ìGICA DE NOMBRE (Ahora ya es seguro ejecutar esto) ---
        # 1. Si hay historial (partida cargada), respetamos el pa√≠s original
        if not self.historial.empty and "Primer_pais" in self.historial.columns:
            val = self.historial["Primer_pais"].iloc[0]
            self.primer_pais = val if val else "Desconocido"
        else:

            # 2. Si NO hay historial (partida nueva), usamos tu configuraci√≥n de options.py
            nombre_target = self.opt.PAIS_INICIO
            # Verificamos si existe en la columna de nombres del DF
            if nombre_target in self.dataframe["Country Name"].values:
                self.primer_pais = nombre_target
            else:
                self.primer_pais = "Desconocido (Error Nombre)"
            
        # Cargar mapa y modelo...
        self.mapa = self.csv.cargar_mapa(self.dataframe)
        self.sir = SIR(mapa_mundo=self.mapa, df=self.dataframe, opt=self.opt)
                    
        # Precarga de vecinos (igual que antes)
        if self.primer_pais and self.primer_pais != "Desconocido":
            vecinos = self.sir.buscar_vecinos(self.primer_pais)
            self.indices_vecinos_zona_cero = np.array(vecinos) if vecinos else np.array([])
        else:
            self.indices_vecinos_zona_cero = np.array([])
    
    def avanzar_dia(self):
        # 1. AUMENTAR D√çA
        self.dia_simulacion += 1
        
        # Calculamos totales actuales para tomar decisiones
        infectados_totales = self.dataframe["I"].sum()
        sanos_totales = self.dataframe["S"].sum()
        historia_pandemia = self.dataframe["R"].sum() + self.dataframe["M"].sum()
        poblacion_total = sanos_totales + infectados_totales + historia_pandemia

        # =================================================================
        # 2. L√ìGICA DE INICIO (Paciente Cero)
        # =================================================================
        # Si no hay infectados Y NADIE ha muerto ni se ha recuperado (Inicio virgen)
        if infectados_totales == 0 and historia_pandemia == 0:
            print("‚ò£Ô∏è Paciente Cero detectado.")
            self.sir.infectar_primera_vez()
            
            pais_idx = self.opt.PAIS_INICIO
            if pais_idx in self.dataframe.index:
                self.primer_pais = self.dataframe.loc[pais_idx, "Country Name"]
            else:
                self.primer_pais = "Desconocido"
            
            # Reiniciar d√≠a si empezamos de cero
            self.dia_simulacion = 1
            self.db = False 
            
            # Recalculamos para que el status no d√© "Humanos Ganan" en este mismo tick
            infectados_totales = self.dataframe["I"].sum()

        # =================================================================
        # 3. VERIFICAR ESTADO DEL JUEGO
        # =================================================================
        status = "Jugando"

        if poblacion_total == 0:
            status = "Cargando..."
        elif sanos_totales <= 0:
            status = "Virus Gana"
        elif infectados_totales <= 0 and historia_pandemia > 0:
            # Solo ganan los humanos si hubo virus alguna vez y se extingui√≥
            status = "Humanos Ganan"

        # Si el juego termin√≥, devolvemos resultado final inmediatamente
        if status != "Jugando":
            return {
                "status": status,
                "dia": str(self.dia_simulacion),
                "datos": self.dataframe.to_dict(orient="records"),
                "totales": {
                    "S": int(self.dataframe["S"].sum()),
                    "I": int(self.dataframe["I"].sum()),
                    "R": int(self.dataframe["R"].sum()),
                    "M": int(self.dataframe["M"].sum())
                }
            }
            
        self.sir.procesar_fronteras_inteligente()
        self.sir.actualizar_cooldowns()
                
        if "vuelo" in self.dataframe.columns:
            self.sir.procesar_logistica(tipo_transporte="vuelo")
        
        if "puerto" in self.dataframe.columns:
            self.sir.procesar_logistica(tipo_transporte="puerto")


        # =================================================================
        # 5. MATEM√ÅTICAS SIRD (Pasando el d√≠a actual para la regla del d√≠a 15)
        # =================================================================
        resultado = self.sir.ejecutar(dia_actual=self.dia_simulacion)
        
        try:
            self.csv.guardar_estados(resultado, self.primer_pais)
        except Exception as e:
            print(e)
             

        return {
            "status": "PLAYING",
            "dia": str(self.dia_simulacion),
            "totales": {
                "S": int(resultado["S"].sum()),
                "I": int(resultado["I"].sum()),
                "R": int(resultado["R"].sum()),
                "M": int(resultado["M"].sum())
            },
            "datos": resultado.to_dict(orient="records")
        }

--- FIN DE ARCHIVO: backend/engine.py ---

--- INICIO DE ARCHIVO: backend/sir_model.py ---
import pandas as pd
import numpy as np

class SIR:
    def __init__(self, mapa_mundo, df, opt):
        self.mapa_mundo = mapa_mundo
        self.df = df
        self.opt = opt 
        self._inicializar_cache()

    def _inicializar_cache(self):
        filtro = "accesible|oc√©ano|mar|rutas internacionales"
        self._mascara_vuelos = self.df["vuelo"].astype(str).str.lower().str.contains(filtro)
        self._mascara_puertos = self.df["puerto"].astype(str).str.lower().str.contains(filtro)



    def infectar_primera_vez(self):
        infectados_iniciales = self.opt.INFECTADOS_INICIALES
        
        # --- CAMBIO: B√öSQUEDA POR NOMBRE ---
        nombre_objetivo = self.opt.PAIS_INICIO
        
        # Buscamos el √≠ndice en el mapa (O(1) - Muy r√°pido)
        paciente_cero_index = self.mapa_mundo.get(nombre_objetivo)
        
        # Blindaje: Si escribiste mal el nombre, usamos el primer pa√≠s disponible
        if paciente_cero_index is None:
            print(f"‚ö†Ô∏è ERROR CR√çTICO: No encuentro el pa√≠s '{nombre_objetivo}' en la base de datos.")
            print("‚û°Ô∏è Usando el primer pa√≠s de la lista como fallback.")
            paciente_cero_index = self.df.index[0]
            # Opcional: Actualizar el nombre en opciones para que la UI lo sepa
            self.opt.PAIS_INICIO = self.df.at[paciente_cero_index, "Country Name"]
        
        # El resto sigue igual...
        poblacion_pais = self.df.loc[paciente_cero_index, "poblacion"]
        infectados_reales = min(infectados_iniciales, poblacion_pais)
        
        self.df.loc[paciente_cero_index,"S"] -= infectados_reales
        self.df.loc[paciente_cero_index,"I"] += infectados_reales
        



    def actualizar_cooldowns(self):
        """Resta 1 d√≠a al contador de espera de todos los pa√≠ses"""
        # Usamos vectorizaci√≥n para restar 1, pero sin bajar de 0
        self.df["cooldown_vuelo"] = np.maximum(0, self.df["cooldown_vuelo"] - 1)
        self.df["cooldown_puerto"] = np.maximum(0, self.df["cooldown_puerto"] - 1)
        self.df["cooldown_frontera"] = np.maximum(0, self.df["cooldown_frontera"] - 1)

        
    def procesar_fronteras_inteligente(self):
        """
        L√≥gica de contagio vecinal:
        1. Emisor > 20% Infectados.
        2. Cooldown Frontera == 0.
        3. Elige 1 vecino aleatorio disponible.
        """
        # 1. Filtramos pa√≠ses peligrosos (Emisores)
        poblacion_minima = 1
        pct_infectados = self.df["I"] / np.maximum(self.df["poblacion"], poblacion_minima)

        condicion_infeccion = (pct_infectados >= self.opt.UMBRAL_PCT_FRONTERA) | \
                              (self.df["I"] > self.opt.UMBRAL_INFECCION_EXTERNO)
        
        mask_emisores = (
            (pct_infectados >= self.opt.UMBRAL_PCT_FRONTERA) &
            (self.df["cooldown_frontera"] == 0) &
            (self.df["vecinos"] != "No") # Que tenga vecinos
        )
        
        indices_emisores = self.df[mask_emisores].index.tolist()
        
        if not indices_emisores: return # Nadie puede infectar hoy

        infectados_nuevos = []

        # 2. Iteramos solo sobre los pa√≠ses peligrosos
        for emisor_idx in indices_emisores:
            # Obtenemos la cadena de vecinos "China, Russia, Mongolia"
            vecinos_str = self.df.at[emisor_idx, "vecinos"]
            if not vecinos_str or vecinos_str == "No": continue

            lista_vecinos_nombres = [v.strip() for v in vecinos_str.split(",")]
            
            # Convertimos nombres a √≠ndices num√©ricos usando self.mapa_mundo
            # (Optimizacion: self.mapa_mundo es un dict {"Nombre": Indice})
            vecinos_indices = []
            for nombre in lista_vecinos_nombres:
                 # --- FIX: Ignorar si dice "Ninguno" o "No" ---
                 if "Ninguno" in nombre or nombre == "No": continue
                 
                 idx = self.mapa_mundo.get(nombre)
                 if idx is None:
                    # print(f"‚ö†Ô∏è ALERTA: No encuentro el pa√≠s vecino '{nombre}' en el mapa.") # Opcional: comentar el print
                    continue
                 
                 vecinos_indices.append(idx)
            
            if not vecinos_indices: continue

            # 3. Filtramos: Solo vecinos que est√©n SANOS (o con poca infecci√≥n si quisieras)
            # Para este juego, asumiremos que atacamos a cualquiera, 
            # pero solo 'cuenta' si tiene sanos disponibles.
            vecinos_validos = [idx for idx in vecinos_indices if self.df.at[idx, "S"] > 0]
            
            if vecinos_validos:
                # 4. DADO: Elegir UNO al azar
                victima_idx = np.random.choice(vecinos_validos)
                
                # Infectamos a la v√≠ctima
                infectados_nuevos.append(victima_idx)
                
                # CASTIGO: Cooldown al emisor
                self.df.at[emisor_idx, "cooldown_frontera"] = self.opt.DIAS_COOLDOWN_FRONTERA
                
                # Debug (Opcional)
                # print(f"üö∂ Frontera: {self.df.at[emisor_idx, 'Country Name']} -> {self.df.at[victima_idx, 'Country Name']}")

        # Aplicar infecciones en lote
        if infectados_nuevos:
            self.infectar_multiples(np.array(infectados_nuevos))

    def procesar_logistica(self, tipo_transporte="vuelo"):
        """
        L√≥gica avanzada:
        1. Emisor debe tener > 40% infectados.
        2. Emisor debe tener cooldown == 0.
        3. Elige 1 v√≠ctima al azar.
        4. Aplica cooldown al emisor.
        """
        # Seleccionar columna y cooldown correcto
        col_cooldown = "cooldown_vuelo" if tipo_transporte == "vuelo" else "cooldown_puerto"
        mascara_conexion = self._mascara_vuelos if tipo_transporte == "vuelo" else self._mascara_puertos
        
        # 1. IDENTIFICAR EMISORES (Pa√≠ses peligrosos)
        # Regla: Tienen conexi√≥n + Infectados > 40% + Cooldown en 0
        poblacion_minima = 1 # Evitar div por cero
        pct_infectados = self.df["I"] / np.maximum(self.df["poblacion"], poblacion_minima)
        
        # Filtro booleano vectorizado (Muy r√°pido)
        emisores_validos = (
            mascara_conexion & 
            (pct_infectados >= self.opt.UMBRAL_PCT_TRANSPORTE) & 
            (self.df[col_cooldown] == 0) &
            (self.df["I"] > 0)
        )
        
        indices_emisores = self.df[emisores_validos].index.tolist()
        
        if not indices_emisores:
            return # Nadie cumple los requisitos para atacar hoy

        # 2. IDENTIFICAR V√çCTIMAS POTENCIALES (Cualquiera con conexi√≥n y Sano)
        # Asumimos "Global Connection": Si tienes aeropuerto, puedes ir a cualquier aeropuerto
        victimas_validas = (
            mascara_conexion & 
            (self.df["I"] == 0) & 
            (self.df["S"] > 0)
        )
        indices_victimas = self.df[victimas_validas].index.tolist()

        if not indices_victimas:
            return # Ya no queda nadie sano con aeropuerto/puerto

        # 3. LANZAR LOS DADOS (Iteraci√≥n optimizada)
        # Solo iteramos sobre los emisores, que ser√°n pocos al inicio.
        nuevos_infectados = []
        
        # Barajamos v√≠ctimas para evitar sesgos
        np.random.shuffle(indices_victimas)
        
        for emisor_idx in indices_emisores:
            if not indices_victimas: break # Se acabaron las v√≠ctimas
            
            # Probabilidad de √©xito del viaje (Opcional: a√±adir factor de riesgo)
            if np.random.random() < self.opt.PROBABILIDAD_INFECTAR_VUELO:
                # Tomamos una v√≠ctima y la sacamos de la lista (para que no la infecten 2 veces hoy)
                victima = indices_victimas.pop() 
                nuevos_infectados.append(victima)
                
                # CASTIGO AL EMISOR: Cooldown de 3 d√≠as
                self.df.at[emisor_idx, col_cooldown] = self.opt.DIAS_COOLDOWN_TRANSPORTE
                
                # Debug en consola (√∫til para verificar que funciona)
                nombre_emisor = self.df.at[emisor_idx, "Country Name"]
                nombre_victima = self.df.at[victima, "Country Name"]

        # 4. APLICAR INFECCI√ìN
        if nuevos_infectados:
            self.infectar_multiples(np.array(nuevos_infectados))

    def infectar_multiples(self, indices):
        if len(indices) == 0: return
        sanos_disponibles = self.df.loc[indices, "S"]
        infectados_reales = np.minimum(self.opt.INFECTADOS_INICIALES_VECINOS, sanos_disponibles)
        self.df.loc[indices, "S"] -= infectados_reales
        self.df.loc[indices, "I"] += infectados_reales

    def buscar_vecinos(self, pais_infectado): 
        lista_paises = self.df[self.df["Country Name"] == pais_infectado]
        if lista_paises.empty: return None
        vecinos = list(lista_paises["vecinos"])
        if not vecinos: return None
        paises = vecinos[0].split(",")
        indexses = []
        for i in paises:
            index = self.mapa_mundo.get(i.strip())
            if index is not None: indexses.append(index)
        if not indexses: return None
        else:
            infectados = self.df.loc[indexses]
            return infectados[infectados["I"] == 0].index.tolist()

    def buscar_vuelos_y_puertos(self, tipo):
        tiene_conexion = self._mascara_vuelos if tipo == "vuelo" else self._mascara_puertos
        emisores = tiene_conexion & (self.df["I"] > self.opt.UMBRAL_INFECCION_EXTERNO)
        if emisores.sum() == 0: return [], 0
        victimas = tiene_conexion & (self.df["I"] == 0) & (self.df["S"] > 0)
        return self.df[victimas].index.tolist(), emisores.sum()

    # =========================================================
    # FUNCI√ìN EJECUTAR MODIFICADA
    # =========================================================
    def ejecutar(self, dia_actual):
        # 1. Cargar tasas base
        self.df["beta"] = self.opt.beta
        
        if dia_actual <= 4:
            self.df["gamma"] = 0.0
            self.df["mu"] = 0.0
        else:
            # A partir del d√≠a 16, usamos los valores de los sliders
            self.df["gamma"] = self.opt.gamma
            self.df["mu"] = self.opt.mu

        # ----------------------------------------------------

        # C√°lculos SIRD (Vectorizado)
        sano_a_infectado = self.df["beta"] * self.df["S"] * self.df["I"] / (self.df["poblacion"] + 1)
        sano_a_infectado = sano_a_infectado.clip(upper=self.df["S"])

        infectado_a_recuperado = self.df["I"] * self.df["gamma"]
        infectado_a_muerto = self.df["I"] * self.df["mu"]

        total_salidas = infectado_a_recuperado + infectado_a_muerto
        factor = np.ones_like(self.df["I"])
        mask_exceso = total_salidas > self.df["I"]
        if mask_exceso.any():
            factor[mask_exceso] = self.df.loc[mask_exceso, "I"] / (total_salidas[mask_exceso] + 1e-9)

        infectado_a_recuperado *= factor
        infectado_a_muerto *= factor
        
        self.df["S"] -= sano_a_infectado
        self.df["I"] += (sano_a_infectado - infectado_a_recuperado - infectado_a_muerto)
        self.df["R"] += infectado_a_recuperado
        self.df["M"] += infectado_a_muerto

        # =============================================================
        # LIMPIEZA AUTOM√ÅTICA (Solo aplica DESPU√âS del d√≠a 15)
        # =============================================================
        if dia_actual > 15:
            tasa_salida_total = self.df["gamma"] + self.df["mu"]
            
            # Solo limpiamos si hay MENOS de 1 infectado (residuos decimales 0.005, etc)
            # Antes usabas UMBRAL_ERRADICACION (10), pero es mejor usar < 1.0 para ser precisos.
            erradicacion = (self.df["I"] > 0) & \
                           (self.df["I"] < self.opt.UMBRAL_ERRADICACION) & \
                           (tasa_salida_total > 0)

            if erradicacion.any():
                infectados_restantes = self.df.loc[erradicacion, "I"].copy()
                
                gamma_vec = self.df.loc[erradicacion, "gamma"]
                total_vec = tasa_salida_total[erradicacion]
                
                # Evitar divisi√≥n por cero
                prop_recuperacion = np.zeros_like(gamma_vec)
                mask_total_pos = total_vec > 0
                prop_recuperacion[mask_total_pos] = gamma_vec[mask_total_pos] / total_vec[mask_total_pos]
                
                recuperados_finales = (infectados_restantes * prop_recuperacion).round(0)
                muertes_finales = infectados_restantes - recuperados_finales

                self.df.loc[erradicacion, "M"] += muertes_finales
                self.df.loc[erradicacion, "R"] += recuperados_finales
                self.df.loc[erradicacion, "I"] = 0

        # Redondeo seguro para visualizaci√≥n
        cols_a_redondear = ["S", "I", "R", "M"]
        self.df[cols_a_redondear] = self.df[cols_a_redondear].clip(lower=0)        
        
        return self.df

--- FIN DE ARCHIVO: backend/sir_model.py ---

--- INICIO DE ARCHIVO: backend/loader.py ---
import pandas as pd
import sqlite3 as sql
import os

class Loader:
    def __init__(self, opt_instance):
        self.opt = opt_instance

    def _reparar_columnas(self, df):
        """Asegura que existan las columnas cr√≠ticas"""
        columnas_texto = ["vuelo", "puerto", "vecinos", "Country Code", "Country Name"]
        for col in columnas_texto:
            if col not in df.columns:
                df[col] = "No"

        if "cooldown_vuelo" not in df.columns:
            df["cooldown_vuelo"] = 0
        if "cooldown_puerto" not in df.columns:
            df["cooldown_puerto"] = 0
        if "cooldown_frontera" not in df.columns:
            df["cooldown_frontera"] = 0
        return df

    def cargar_mapa(self, df):
        if "Country Name" not in df.columns: return {}
        return dict(zip(df["Country Name"], df.index))
    
    def cargar_df(self):
        # Intentar cargar CSV
        if not os.path.exists(self.opt.RUTA_CSV):
            print(f"‚ùå ERROR: No existe {self.opt.RUTA_CSV}")
            return pd.DataFrame(columns=["Country Name", "poblacion", "vuelo", "puerto", "vecinos", "S", "I", "R", "M", "beta", "gamma", "mu"])

        try:
            df = pd.read_csv(self.opt.RUTA_CSV)
        except Exception as e:
            print(f"‚ùå ERROR leyendo CSV: {e}")
            return pd.DataFrame()
        
        # Limpieza y Tipos
        if "poblacion" in df.columns:
            if df["poblacion"].dtype == 'object':
                df["poblacion"] = df["poblacion"].astype(str).str.replace(",", "")
            df["poblacion"] = pd.to_numeric(df["poblacion"], errors='coerce').fillna(0).astype(int)
            df = df[df["poblacion"] > 0] # Eliminar pa√≠ses sin gente
        
        if "Country Name" in df.columns:
            df = df.dropna(subset=["Country Name"])

        df = self._reparar_columnas(df)

        # Inicializaci√≥n de Modelo
        df["S"] = df["poblacion"]
        df["I"] = 0
        df["R"] = 0
        df["M"] = 0
        
        # Par√°metros iniciales
        df["beta"] = self.opt.beta
        df["gamma"] = self.opt.gamma
        df["mu"] = self.opt.mu
        
        # Conversi√≥n a string segura
        df["vuelo"] = df["vuelo"].astype(str)
        df["puerto"] = df["puerto"].astype(str)
        
        return df

    def cargar_db(self):
        try:
            conn = sql.connect(self.opt.RUTA_DB_CREADA)
            df = pd.read_sql("SELECT * FROM estado_actual", conn)
            conn.close()
            
            if df.empty: raise Exception("DB Vac√≠a")
            
            df = self._reparar_columnas(df)
            # Actualizar tasas con los sliders actuales
            df["beta"] = self.opt.beta
            df["gamma"] = self.opt.gamma
            df["mu"] = self.opt.mu
            return df
        except:
            print("‚ö†Ô∏è DB vac√≠a o corrupta. Recargando desde CSV...")
            return self.cargar_df() # Fallback al CSV

    def historial(self):
        try:
            conn = sql.connect(self.opt.RUTA_DB_CREADA)
            df = pd.read_sql("SELECT * FROM historial", conn)
            conn.close()
            return df
        except Exception as e:
            print(e)
            return pd.DataFrame()
        
    def crear_db(self):
        """Crea la DB y LA RELLENA INMEDIATAMENTE con el CSV"""
        os.makedirs(os.path.dirname(self.opt.RUTA_DB_CREADA), exist_ok=True)

        conn = sql.connect(self.opt.RUTA_DB_CREADA)
        cursor = conn.cursor()
        
        # 1. Crear Tablas
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS estado_actual (
                'Country Name' TEXT, 'Country Code' TEXT, 'poblacion' INTEGER,
                'vuelo' TEXT, 'puerto' TEXT, 'vecinos' TEXT,
                'S' INTEGER, 'I' INTEGER, 'R' INTEGER, 'M' INTEGER,
                'beta' REAL, 'gamma' REAL, 'mu' REAL
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS historial( 
                dia TEXT, total_I INTEGER, total_S INTEGER, 
                total_R INTEGER, total_M INTEGER, 
                Primer_pais TEXT, Paises_Infectados INTEGER
            )
        """)
        
        # 2. VERIFICAR SI EST√Å VAC√çA Y LLENARLA
        cursor.execute("SELECT count(*) FROM estado_actual")
        count = cursor.fetchone()[0]
        
        exito = False
        if count == 0:
            print("üì• Inicializando DB con datos del CSV...")
            df = self.cargar_df() # Leemos el CSV
            if not df.empty:
                df.to_sql("estado_actual", conn, if_exists="replace", index=False)
                exito = True
            else:
                print("‚ùå FATAL: El CSV est√° vac√≠o o no se pudo leer.")
        else:
            exito = False # Ya exist√≠a

        conn.commit()
        cursor.close()
        conn.close()
        return exito

    def guardar_estados(self, datos, pais):
        try:
            conn = sql.connect(self.opt.RUTA_DB_CREADA)
            
            # Historial
            ultimo_dia = 0
            try:
                res = pd.read_sql_query("SELECT dia FROM historial ORDER BY ROWID DESC LIMIT 1", conn)
                if not res.empty: ultimo_dia = int(res.iloc[0, 0])
            except: pass
            
            # CONVERSI√ìN EXPL√çCITA A FLOAT PARA EVITAR OVERFLOW EN 32 BITS
            dicc = {
                "total_S": float(datos["S"].astype(float).sum()), 
                "total_R": float(datos["R"].astype(float).sum()),            
                "total_I": float(datos["I"].astype(float).sum()), 
                "total_M": float(datos["M"].astype(float).sum()),
                "dia": ultimo_dia + 1, 
                "Primer_pais": pais,
                "Paises_Infectados": int((datos["I"] > 0).sum())
            }
            
            pd.DataFrame([dicc]).to_sql("historial", conn, if_exists="append", index=False)         
            datos.to_sql("estado_actual", conn, if_exists="replace", index=False)         
            conn.close()
        except Exception as e:
            if conn: conn.close()
            print(f"Error guardando: {e}")

    def limpiar_db(self):
        if os.path.exists(self.opt.RUTA_DB_CREADA):
            try:
                os.remove(self.opt.RUTA_DB_CREADA)
                return {"mensaje": "DB Borrada"}, True
            except: return {"error": "Fallo al borrar"}, False
        return {"mensaje": "No exist√≠a"}, False

--- FIN DE ARCHIVO: backend/loader.py ---

--- INICIO DE ARCHIVO: backend/options.py ---
from PySide6.QtCore import QObject, Signal, Property
import os

class Options(QObject):
    # =========================================================
    # 1. CONSTANTES DE RUTA (Arreglado para carpeta 'backend')
    # =========================================================
    
    # Obtenemos la ruta absoluta de la carpeta donde est√° ESTE archivo (backend/)
    _BACKEND_DIR = os.path.dirname(os.path.abspath(__file__))
    
    # Construimos las rutas apuntando a la carpeta 'data' dentro de 'backend'
    RUTA_DB_CREADA = os.path.join(_BACKEND_DIR, "data", "mundo.db")
    RUTA_CSV = os.path.join(_BACKEND_DIR, "data", "poblacion.csv")

    # Constantes fijas del juego
    PAIS_INICIO = "Venezuela"
    INFECTADOS_INICIALES = 2
    INFECTADOS_INICIALES_VECINOS = 11 # Mayor a umbral de erradicacion siempre
    UMBRAL_INFECCION_EXTERNO = 500
    UMBRAL_ERRADICACION = 10

    # El porcentaje de poblaci√≥n infectada necesario para que salgan aviones/barcos (0.4 = 40%)
    UMBRAL_PCT_TRANSPORTE = 0.40 
    # D√≠as de espera antes de poder volver a infectar por este medio
    DIAS_COOLDOWN_TRANSPORTE = 3
    UMBRAL_PCT_FRONTERA = 0.05   # 20% de infectados para cruzar a pie
    DIAS_COOLDOWN_FRONTERA = 2   # Espera entre contagios vecinales

    # =========================================================
    # 2. SE√ëALES
    # =========================================================
    betaChanged = Signal(float)
    gammaChanged = Signal(float)
    muChanged = Signal(float)
    pFronteraChanged = Signal(float)

    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Debug: Imprimimos la ruta para que verifiques en consola
        print(f"üìÅ BUSCANDO DATOS EN: {self.RUTA_CSV}")

        # =====================================================
        # 3. VARIABLES DIN√ÅMICAS
        # =====================================================
        self._beta = 0.5
        self._gamma = 0.02
        self._mu = 0.005
        self._p_frontera = 1.0
        
        # Probabilidades extra
        self.PROBABILIDAD_INFECTAR_VUELO = 1.0
        self.PROBABILIDAD_INFECTAR_PUERTO = 1.0

    # --- GETTERS Y SETTERS ---
    @Property(float, notify=betaChanged)
    def beta(self): return self._beta

    @beta.setter
    def beta(self, val):
        if self._beta != val:
            self._beta = val
            self.betaChanged.emit(val)

    @Property(float, notify=gammaChanged)
    def gamma(self): return self._gamma

    @gamma.setter
    def gamma(self, val):
        if self._gamma != val:
            self._gamma = val
            self.gammaChanged.emit(val)

    @Property(float, notify=muChanged)
    def mu(self): return self._mu

    @mu.setter
    def mu(self, val):
        if self._mu != val:
            self._mu = val
            self.muChanged.emit(val)

    @Property(float, notify=pFronteraChanged)
    def p_frontera(self): return self._p_frontera

    @p_frontera.setter
    def p_frontera(self, val):
        if self._p_frontera != val:
            self._p_frontera = val
            self.pFronteraChanged.emit(val)

--- FIN DE ARCHIVO: backend/options.py ---

--- INICIO DE ARCHIVO: controllers/sird_controller.py ---
from PySide6.QtCore import QObject, Slot, Signal, Property, QTimer
from backend.engine import Engine
from controllers.mapa_modelo import MapaModeloSIRD
from backend.options import Options

class ControladorSIRD(QObject):
    # Se√±ales
    datosCambios = Signal()
    noticiaCambio = Signal(str)
    statsChanged = Signal() 
    diaChanged = Signal(str) 


    def __init__(self):
        super().__init__()
        
        # 1. Inicializar objetos
        self.opciones = Options()
        self.mapa_modelo = MapaModeloSIRD()
        self.motor = Engine(self.opciones) # Pasamos opciones al motor

        # 2. Variables de estado
        self._dia = "1"
        self._sanos = 0
        self._infectados = 0
        self._recuperados = 0
        self._muertos = 0
        self._paisesInfectados = 0
        self._primerPais = "Esperando..."
        self._noticia = "Preparado. Pulsa Play."
        
        self.timer = QTimer()
        self.timer.timeout.connect(self.tick_simulacion)
        self.isPlaying = False
        self._intervalo_ms = 1000

        # 3. ¬°IMPORTANTE! Cargar datos iniciales (para no ver ceros)
        # Ejecutamos una actualizaci√≥n manual sin avanzar el tiempo
        self.actualizar_interfaz_desde_motor()

    @Property(QObject, constant=True)
    def config(self):
        return self.opciones

    @Property(float, notify=statsChanged)
    def sanos(self): return float(self._sanos)

    @Property(float, notify=statsChanged)
    def infectados(self): return float(self._infectados)

    @Property(float, notify=statsChanged)
    def recuperados(self): return float(self._recuperados)

    @Property(float, notify=statsChanged)
    def muertos(self): return float(self._muertos)
    
    # Este puede quedarse en int porque nunca habr√° m√°s de 200 pa√≠ses
    @Property(int, notify=statsChanged)
    def paisesInfectados(self): return self._paisesInfectados

    @Property(str, notify=statsChanged)
    def primerPais(self): return self._primerPais

    @Property(str, notify=diaChanged)
    def dia(self): return str(self._dia)

    @Property(str, notify=noticiaCambio)
    def noticia(self): return self._noticia


    @Slot(float)
    def cambiar_velocidad(self, valor):
        """
        Recibe valor del slider (0.0 a 2.0)
        Convierte a milisegundos (4000ms a 200ms)
        """
        # TUS L√çMITES
        ms_min = 200     # Lo m√°s r√°pido (l√≠mite del hardware)
        ms_max = 4000    # Lo m√°s lento
        slider_max = 2.0 # El valor 'maximo' que pusiste en el QML

        # 1. Normalizamos: Convertimos el 0..2.0 a 0..1.0
        # Ejemplo: si entra 2.0, factor ser√° 1.0. Si entra 1.0, factor ser√° 0.5
        factor = valor / slider_max 
        
        # 2. Interpolaci√≥n Lineal Inversa
        # Intervalo = Inicio + (Fin - Inicio) * factor
        # Pero como queremos ir de Mayor a Menor, restamos:
        rango = ms_max - ms_min
        nuevo_intervalo = int(ms_max - (factor * rango))
        
        # 3. Seguridad: Nunca bajar del m√≠nimo del hardware
        nuevo_intervalo = max(ms_min, nuevo_intervalo)
        
        self._intervalo_ms = nuevo_intervalo
        
        # Debug para verificar
        print(f"üèéÔ∏è Slider: {valor:.2f} -> Intervalo Real: {self._intervalo_ms} ms")

        # Aplicar inmediatamente si est√° corriendo
        if self.isPlaying:
            self.timer.setInterval(self._intervalo_ms)

    # --- L√ìGICA ---
    @Slot(bool)
    def toggle_simulacion(self, encendido):
        self.isPlaying = encendido
        if encendido:
            print("‚ñ∂Ô∏è Iniciando Timer...")
            self.timer.start(self._intervalo_ms)
        else:
            print("‚è∏Ô∏è Pausando Timer...")
            self.timer.stop()

    @Slot()
    def pausar_simulacion(self):
        self.toggle_simulacion(False)

    @Slot()
    def reiniciar_simulacion(self):
        self.reiniciar()

    @Slot()
    def reiniciar(self):
        print("‚ü≤ Reiniciando...")
        self.timer.stop()
        self.isPlaying = False

        # Limpiar
        if hasattr(self, 'motor'):
            try: self.motor.csv.limpiar_db()
            except: pass

        self.mapa_modelo._inicializar_vacio()
        self.motor = Engine(self.opciones) # Motor nuevo con opciones

        self._noticia = "Simulaci√≥n Reiniciada."
        
        # Cargar estado inicial limpio
        self.actualizar_interfaz_desde_motor()

    def tick_simulacion(self):
        if not self.isPlaying: return
        
        # Avanzar l√≥gica
        resultado = self.motor.avanzar_dia()
        self.procesar_resultado(resultado)

    def actualizar_interfaz_desde_motor(self):
        """Lee el estado actual del motor SIN avanzar el d√≠a"""
        # Forzamos una lectura del estado actual del dataframe
        if hasattr(self.motor, 'dataframe'):
             # Construimos un 'resultado' falso solo para actualizar la UI
             df = self.motor.dataframe
             nombre = getattr(self.motor, 'primer_pais', "Desconocido")

             
             if not nombre or nombre == "Desconocido":
                 # INTENTO DE RESCATE: Si el motor no sabe, miramos si alguien tiene infectados
                 infectados = df[df["I"] > 0]
                 if not infectados.empty:
                     nombre = infectados.iloc[0]["Country Name"]
                 else:
                     # Si nadie est√° infectado a√∫n (D√≠a 0), predecimos qui√©n ser√°
                     idx_target = self.opciones.INDEX_PAIS_A_INFECTAR
                     if idx_target in df.index:
                         nombre = df.loc[idx_target, "Country Name"]
                         
             self._primerPais = str(nombre) if nombre else "Desconocido"
             
             totales = {
                 "S": int(df["S"].sum()),
                 "I": int(df["I"].sum()),
                 "R": int(df["R"].sum()),
                 "M": int(df["M"].sum())
             }
             # Actualizamos variables
             self._sanos = totales["S"]
             self._infectados = totales["I"]
             self._recuperados = totales["R"]
             self._muertos = totales["M"]
             self._dia = "1"
             self.statsChanged.emit()
             self.diaChanged.emit(self._dia)
             self.noticiaCambio.emit(self._noticia)
             
             # Actualizar colores iniciales
             self.mapa_modelo.actualizar_datos(df.to_dict(orient="records"))

    def procesar_resultado(self, resultado):
        status = resultado.get("status", "Jugando")
        
        datos = resultado.get("datos", [])
        if datos: self.mapa_modelo.actualizar_datos(datos)

        totales = resultado.get("totales", {})
        if totales:
            self._sanos = int(totales.get("S", 0))
            self._infectados = int(totales.get("I", 0))
            self._recuperados = int(totales.get("R", 0))
            self._muertos = int(totales.get("M", 0))

        self._dia = str(resultado.get("dia", self._dia))
        self._paisesInfectados = sum(1 for p in datos if p.get("I", 0) > 0)

        self.statsChanged.emit()
        self.diaChanged.emit(self._dia)

        if status != "PLAYING" and status != "Jugando":
            self.pausar_simulacion()
            self._noticia = f"üèÅ FIN: {status}"
            self.noticiaCambio.emit(self._noticia)

    @Slot(result=list)
    def obtener_datos_historial(self):
        """
        Devuelve una lista de 5 listas: [Dias, S, I, R, M]
        Optimizado para graficar r√°pido.
        """
        if not hasattr(self.motor, 'historial'): return []
        
        # Obtenemos el DataFrame del historial
        # Si est√° vac√≠o, intentamos recargar de la DB
        df = self.motor.historial
        if df.empty:
             df = self.motor.csv.historial()
        
        if df.empty: return []

        # Extraemos columnas como listas simples de Python (JSON compatible)
        # Aseguramos que est√©n ordenados por d√≠a
        try:
            # Convertir a num√©rico por seguridad
            dias = df["dia"].astype(int).tolist()
            s = df["total_S"].astype(float).tolist()
            i = df["total_I"].astype(float).tolist()
            r = df["total_R"].astype(float).tolist()
            m = df["total_M"].astype(float).tolist()
            
            return [dias, s, i, r, m]
        except Exception as e:
            print(f"Error extrayendo historial: {e}")
            return []

    @Slot(str, result=list)
    def obtener_ranking_global(self, criterio="I"):
        """
        Devuelve el ranking ordenado seg√∫n el criterio:
        'I': Infectados, 'M': Muertos, 'R': Recuperados, 'S': Sanos
        """
        if not hasattr(self.motor, 'dataframe'): return []
        
        df = self.motor.dataframe.copy()
        
        # Evitar divisi√≥n por cero
        df["poblacion"] = df["poblacion"].replace(0, 1)
        
        # Seleccionamos la columna clave para ordenar
        col_sort = "I"
        if criterio == "M": col_sort = "M"
        elif criterio == "R": col_sort = "R"
        elif criterio == "S": col_sort = "S"
        
        # Calculamos el ratio espec√≠fico para la barra de progreso
        df["ratio"] = df[col_sort] / df["poblacion"]
        
        # Ordenamos de Mayor a Menor
        df_sorted = df.sort_values(by=col_sort, ascending=False)
        
        # Extraemos Top 200
        resultado = []
        for index, row in df_sorted.iterrows():
            # Filtro visual: Si el valor es 0, quiz√°s no queramos mostrarlo (opcional)
            # Pero para Sanos siempre habr√°, as√≠ que lo dejamos pasar.
            
            resultado.append({
                "nombre": str(row["Country Name"]),
                "codigo": str(row.get("Country Code", "???")),
                "poblacion": int(row["poblacion"]),
                "valor": int(row[col_sort]), # El valor principal (ej. Muertos)
                "ratio": float(row["ratio"]), # Para la barra (0.0 a 1.0)
                "infectados": int(row["I"]),    # Datos extra por si acaso
                "muertos": int(row["M"]),
                "recuperados": int(row["R"]),
                "sanos": int(row["S"])
            })
                
        return resultado

    @Slot(str, result='QVariantMap')
    def obtener_detalle_pais(self, codigo_pais):
        """
        Calcula todos los datos necesarios para la gr√°fica de pastel en Python.
        Retorna un diccionario listo para QML.
        """
        # Buscamos en el modelo de mapa (que ya tiene los datos frescos del √∫ltimo tick)
        datos = next((p for p in self.mapa_modelo.paises if p["codigo"] == codigo_pais), None)
        
        if not datos:
            return {"existe": False}
            
        pob = datos["poblacion"]
        i = datos["infectado"]
        r = datos["recuperado"]
        m = datos.get("muerto", 0) # Asegurar que existe
        
        # Matem√°ticas aqu√≠, no en QML
        s = pob - i - r - m
        if s < 0: s = 0 # Correcci√≥n de seguridad
        
        return {
            "existe": True,
            "nombre": datos["nombre"],
            "poblacion": pob,
            "valS": s,
            "valI": i,
            "valR": r,
            "valM": m,
            # Pre-calculamos porcentajes para tooltips (ahorramos JS)
            "pctS": (s/pob)*100,
            "pctI": (i/pob)*100,
            "pctR": (r/pob)*100,
            "pctM": (m/pob)*100
        }

--- FIN DE ARCHIVO: controllers/sird_controller.py ---

--- INICIO DE ARCHIVO: controllers/mapa_modelo.py ---
from PySide6.QtCore import QAbstractListModel, Qt, Slot
import json
import os

class MapaModeloSIRD(QAbstractListModel):
    CodigoRole = Qt.UserRole + 1
    NombreRole = Qt.UserRole + 2
    PathRole = Qt.UserRole + 3
    InfectadoRole = Qt.UserRole + 4
    RecuperadoRole = Qt.UserRole + 5
    ColorRole = Qt.UserRole + 6 
    MuertoRole = Qt.UserRole + 7
    PoblacionRole = Qt.UserRole + 8

    def __init__(self, parent=None):
        super().__init__(parent)
        self.paises = []
        
        # Cargar geometr√≠a del mapa
        try:
            # Truco para ruta segura
            BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            json_path = os.path.join(BASE_DIR, "ui", "assets", "paises.json")
            with open(json_path, encoding='utf-8') as f:
                self.geometria = json.load(f)
        except Exception as e:
            print(f"‚ùå Error cargando paises.json: {e}")
            self.geometria = {}

        self._inicializar_vacio()

    def _inicializar_vacio(self):
        """Estado inicial: Todo azul tranquilo"""
        self.beginResetModel()
        self.paises = []
        for codigo, path in self.geometria.items():
            self.paises.append({
                "codigo": codigo,
                "nombre": codigo, 
                "path": path,
                "infectado": 0,
                "recuperado": 0,
                "poblacion": 1, 
                "color": "#A2B2F3"
            })
        self.endResetModel()

    def roleNames(self):
        return {
            self.CodigoRole: b"codigo",
            self.NombreRole: b"nombre",
            self.PathRole: b"path",
            self.InfectadoRole: b"infectado",
            self.RecuperadoRole: b"recuperado",
            self.ColorRole: b"color_pais",
            self.MuertoRole: b"muerto",     
            self.PoblacionRole: b"poblacion"
        }

    def rowCount(self, parent=None):
        return len(self.paises)

    def data(self, index, role):
        if not index.isValid() or index.row() >= len(self.paises): return None
        pais = self.paises[index.row()]
        
        if role == self.CodigoRole: return pais["codigo"]
        if role == self.NombreRole: return pais["nombre"]
        if role == self.PathRole: return pais["path"]
        if role == self.InfectadoRole: return pais["infectado"]
        if role == self.RecuperadoRole: return pais["recuperado"]
        if role == self.ColorRole: return pais["color"]
        if role == self.MuertoRole: return pais.get("muerto", 0) #.get por seguridad
        if role == self.PoblacionRole: return pais["poblacion"]
        return None

    @Slot(str, result=str)
    def get_datos_pais_html(self, codigo_pais):
        for pais in self.paises:
            if pais["codigo"] == codigo_pais:
                pob = pais['poblacion'] if pais['poblacion'] > 0 else 1
                pct = (pais['infectado'] / pob) * 100
                return (f"<b>{pais['nombre']}</b> ({pais['codigo']})<br>"
                        f"üë• Poblaci√≥n: {pob:,}<br>"
                        f"ü§í Infectados: {pais['infectado']:,} ({pct:.2f}%)<br>"
                        f"üíö Recuperados: {pais['recuperado']:,}")
        return "Sin datos"

    def calcular_color_hex(self, porcentaje):
        # Gradiente normalizado 0.0 a 1.0
        stops = [
            (0.00, 162, 178, 243), # Azul Base
            (0.25, 156, 39, 176),  # Morado
            (0.50, 233, 30, 99),   # Rosa
            (0.75, 213, 0, 0),     # Rojo
            (1.00, 100, 0, 0)      # Rojo Oscuro
        ]
        for i in range(len(stops) - 1):
            t1, r1, g1, b1 = stops[i]
            t2, r2, g2, b2 = stops[i+1]
            if porcentaje <= t2:
                factor = (porcentaje - t1) / (t2 - t1)
                r = int(r1 + (r2 - r1) * factor)
                g = int(g1 + (g2 - g1) * factor)
                b = int(b1 + (b2 - b1) * factor)
                return f"#{r:02x}{g:02x}{b:02x}"
        return "#640000"

    def actualizar_datos(self, lista_paises):
        if not self.paises or not lista_paises: return
        
        # Diccionario para acceso r√°pido O(1)
        datos_dict = { fila["Country Code"]: fila for fila in lista_paises if "Country Code" in fila }
        
        hay_cambios = False
        idx_min, idx_max = len(self.paises), 0

        for i, pais in enumerate(self.paises):
            codigo = pais["codigo"]
            if codigo in datos_dict:
                dato = datos_dict[codigo]
                
                i_val = int(dato.get("I", 0))
                r_val = int(dato.get("R", 0))
                m_val = int(dato.get("M", 0))
                pob = int(dato.get("S", 0)) + i_val + r_val + m_val
                
                if pob <= 0: pob = 1
                pais["poblacion"] = pob
                pais["infectado"] = i_val
                pais["recuperado"] = r_val
                
                if "Country Name" in dato:
                    pais["nombre"] = dato["Country Name"]
                
                # Color
                pct = (i_val + r_val + m_val) / pob
                nuevo_color = self.calcular_color_hex(pct)
                
                if pais["color"] != nuevo_color:
                    pais["color"] = nuevo_color
                    hay_cambios = True
                    idx_min = min(idx_min, i)
                    idx_max = max(idx_max, i)

        if hay_cambios:
            top = self.index(idx_min, 0)
            bot = self.index(idx_max, 0)
            self.dataChanged.emit(top, bot, [self.ColorRole, self.InfectadoRole, self.RecuperadoRole])

--- FIN DE ARCHIVO: controllers/mapa_modelo.py ---

--- INICIO DE ARCHIVO: ui/main.qml ---
import QtQuick
import QtQuick.Controls
import components

ApplicationWindow {
    id: mainWindow
    visible: true
    width: 1200
    height: 720
    title: "Simulador SIRD - Dashboard"
    color: "#121212"

    // Propiedad de estado: controla si vemos el "mapa" o el "grafico"
    property string vistaActual: "mapa"

    // 1. BARRA SUPERIOR
    header: BarraSuperior {
        visible: mainWindow.vistaActual === "mapa"
        onMenuClicked: opcionesDrawer.opened ? opcionesDrawer.close() : opcionesDrawer.open()

        // Conexi√≥n al Backend
        onPlayPauseClicked: (isPlaying) => {
            if(backend) backend.toggle_simulacion(isPlaying);
        }

        onResetClicked: {
            if(backend) backend.reiniciar();
        }
    }

    // 2. BARRA INFERIOR
    footer: BarraInferior {
        id: barraInf
        visible: mainWindow.vistaActual === "mapa"
        
        // Data Bindings seguros
        dia: backend ? backend.dia : "1"
        primerPaisNombre: backend ? backend.primerPais : "..."
        
        sanos: backend ? backend.sanos : 0
        infectados: backend ? backend.infectados : 0
        recuperados: backend ? backend.recuperados : 0
        muertos: backend ? backend.muertos : 0
        paisesInfectados: backend ? backend.paisesInfectados : 0
        noticiaActual: backend ? backend.noticia : "Cargando..."
    }

    // 3. MEN√ö LATERAL (Drawer)
    MenuOpciones {
        id: opcionesDrawer
        y: header.height
        height: parent.height - header.height - footer.height
    }

    // 4. CONTENEDOR PRINCIPAL (Loader Din√°mico)
    Item {
        anchors.top: parent.top
        anchors.bottom: parent.bottom
        anchors.right: parent.right
        anchors.left: parent.left
        
        // Efecto visual: El contenido se encoge cuando sale el men√∫
        anchors.leftMargin: opcionesDrawer.position * opcionesDrawer.width
        scale: vistaActual === "mapa" ? (1.0 - (opcionesDrawer.position * 0.15)) : 1.0

        // EL CEREBRO DE LA OPTIMIZACI√ìN:
        // Carga y destruye componentes seg√∫n se necesiten
        Loader {
            id: mainLoader
            anchors.fill: parent
            sourceComponent: {
                        if (mainWindow.vistaActual === "grafico") return compGrafico;
                        if (mainWindow.vistaActual === "ranking") return compRanking; // NUEVO
                        return compMapa;
            }
        }
    }

    // --- COMPONENTES DIN√ÅMICOS ---

    // A) El Mapa (Se destruye al ver gr√°ficas para ahorrar CPU)
    Component {
        id: compMapa
        Mapa {
            anchors.fill: parent
        }
    }

    // B) El Gr√°fico Hist√≥rico
    Component {
        id: compGrafico
        VistaGrafica {
            anchors.fill: parent
            // Al volver, restauramos la vista del mapa
            onVolverClicked: {
                mainWindow.vistaActual = "mapa"
            }
        }
    }

    Component {
        id: compRanking
        VistaRanking {
            anchors.fill: parent
            onVolverClicked: mainWindow.vistaActual = "mapa"
        }
    }
}

--- FIN DE ARCHIVO: ui/main.qml ---

--- INICIO DE ARCHIVO: ui/components/Mapa.qml ---
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Shapes 1.15

Item {
    id: mapRoot
    anchors.fill: parent
    clip: true

    // =========================================================
    // 1. TOOLTIP (Variables Globales)
    // =========================================================
    property string tooltipHtml: ""
    property bool isTooltipVisible: false
    property real tipX: 0
    property real tipY: 0

    // =========================================================
    // 2. L√ìGICA DE ZOOM (Doble Clic con Animaci√≥n)
    // =========================================================
    function flyToCountry(mapX, mapY) {
        let targetScale = 6.0
        
        // Calculamos d√≥nde debe quedar el mapa
        let newX = (mapRoot.width / 2) - (mapX * targetScale)
        let newY = (mapRoot.height / 2) - (mapY * targetScale)

        // Preparamos la animaci√≥n
        animScale.from = mapContainer.scale
        animScale.to = targetScale
        
        animX.from = mapContainer.x
        animX.to = newX
        
        animY.from = mapContainer.y
        animY.to = newY
        
        // ¬°Arrancamos el vuelo suave!
        zoomAnim.restart()
    }

    // Animaci√≥n SOLO para el doble clic o botones (no afecta la rueda)
    ParallelAnimation {
        id: zoomAnim
        NumberAnimation { id: animX; target: mapContainer; property: "x"; duration: 600; easing.type: Easing.OutCubic }
        NumberAnimation { id: animY; target: mapContainer; property: "y"; duration: 600; easing.type: Easing.OutCubic }
        NumberAnimation { id: animScale; target: mapContainer; property: "scale"; duration: 600; easing.type: Easing.OutCubic }
    }

    // Zoom manual (Botones) - Usa animaci√≥n
    function setZoomManual(factor) {
        let newScale = mapContainer.scale * factor
        newScale = Math.max(0.5, Math.min(newScale, 30.0))
        
        // Hacemos zoom al centro de la pantalla
        let centerOffsetX = (mapRoot.width / 2 - mapContainer.x) / mapContainer.scale
        let centerOffsetY = (mapRoot.height / 2 - mapContainer.y) / mapContainer.scale
        
        let newX = (mapRoot.width / 2) - (centerOffsetX * newScale)
        let newY = (mapRoot.height / 2) - (centerOffsetY * newScale)

        animScale.from = mapContainer.scale
        animScale.to = newScale
        animX.from = mapContainer.x
        animX.to = newX
        animY.from = mapContainer.y
        animY.to = newY
        zoomAnim.restart()
    }

    // =========================================================
    // 3. CONTENEDOR DEL MAPA
    // =========================================================
    Item {
        id: mapContainer
        width: 1010
        height: 660
        x: (parent.width - width) / 2
        y: (parent.height - height) / 2
        scale: 0.9
        transformOrigin: Item.TopLeft 

        // NOTA: He borrado los "Behavior on x/y/scale". 
        // Esto hace que el movimiento sea instant√°neo y muy r√°pido.

        // A) Arrastre del fondo
        DragHandler {
            target: mapContainer
            acceptedButtons: Qt.LeftButton
        }

        // B) Zoom con Rueda (INSTANT√ÅNEO)
        WheelHandler {
            target: mapContainer
            onWheel: (event) => {
                let zoomFactor = event.angleDelta.y > 0 ? 1.15 : 0.85
                
                // Calcular posici√≥n del mouse relativa al mapa antes del zoom
                let mouseX_in_map = (event.x - mapContainer.x) / mapContainer.scale
                let mouseY_in_map = (event.y - mapContainer.y) / mapContainer.scale
                
                let newScale = Math.max(0.5, Math.min(mapContainer.scale * zoomFactor, 30.0))
                
                // Aplicar cambios directamente (sin animaci√≥n)
                mapContainer.x = event.x - (mouseX_in_map * newScale)
                mapContainer.y = event.y - (mouseY_in_map * newScale)
                mapContainer.scale = newScale
            }
        }

        // C) Pa√≠ses
        Repeater {
            model: mapa_modelo

            Shape {
                id: countryShape
                width: 1010
                height: 660
                containsMode: Shape.FillContains

                ShapePath {
                    strokeWidth: 1.0 / mapContainer.scale 
                    strokeColor: "white"
                    fillColor: (model.color_pais && model.color_pais !== "") ? model.color_pais : "#CFD8DC"
                    fillRule: ShapePath.WindingFill
                    PathSvg { path: model.path }
                }

            MouseArea {
                id: countryMouse
                anchors.fill: parent
                hoverEnabled: true
                containmentMask: countryShape
                cursorShape: pressed ? Qt.ClosedHandCursor : Qt.PointingHandCursor
                drag.target: mapContainer
                drag.filterChildren: true
                
                onDoubleClicked: (mouse) => {
                // 1. ZOOM (Tu l√≥gica original)
                    let mapPoint = mapContainer.mapFromItem(countryMouse, mouse.x, mouse.y)
                    mapRoot.flyToCountry(mapPoint.x, mapPoint.y)
                
                    // 2. DATOS DEL MODELO
                    // Obtenemos los datos directamente del modelo actual (Repeater)
                    var s = model.poblacion - model.infectado - model.recuperado // S calculado aprox o usar si lo tienes en modelo
                    // Nota: Tu modelo actual tiene 'poblacion', 'infectado', 'recuperado'. 
                    // Calculamos S y M (si lo tienes en el modelo a√±adelo, sino M=0 por ahora)
                
                    // NOTA IMPORTANTE: Para eficiencia, accedemos a las propiedades del modelo QML
                    var i = model.infectado
                    var r = model.recuperado
                    var pob = model.poblacion
                    var m = 0 // Si tu modelo tiene muertos, usa model.muertos
                    var s_calc = pob - i - r - m
                
                    // 3. POSICI√ìN DE PANTALLA
                    // Convertimos la coordenada del clic (local al pa√≠s) a coordenada global de la ventana
                    var screenPos = countryMouse.mapToItem(mapRoot, mouse.x, mouse.y)
                
                    // 4. ABRIR POPUP
                    infoPaisPopup.abrir(
                        screenPos.x, 
                        mapRoot.width, 
                        mapRoot.height, 
                        model.codigo 
                    )
                    }
                }
            }
        }
    }

    // =========================================================
    // 4. EL TOOLTIP
    // =========================================================
    Rectangle {
        visible: mapRoot.isTooltipVisible
        x: mapRoot.tipX
        y: mapRoot.tipY
        z: 9999
        width: infoTxt.contentWidth + 24
        height: infoTxt.contentHeight + 16
        color: "#2d3436"
        radius: 4
        border.color: "white"
        opacity: 0.95

        Text {
            id: infoTxt
            anchors.centerIn: parent
            text: mapRoot.tooltipHtml
            color: "white"
            font.pixelSize: 13
            textFormat: Text.RichText
        }
    }

    // =========================================================
    // 5. BOTONES
    // =========================================================
    Column {
        anchors.right: parent.right
        anchors.bottom: parent.bottom
        anchors.margins: 20
        spacing: 10
        RoundButton {
            width: 50; height: 50; text: "+"; font.pixelSize: 24
            onClicked: mapRoot.setZoomManual(1.5)
        }
        RoundButton {
            width: 50; height: 50; text: "-"; font.pixelSize: 24
            onClicked: mapRoot.setZoomManual(0.6)
        }
    }
    PieChartPopup {
            id: infoPaisPopup
            // Se asegura de estar encima del mapa
            z: 9999 
    }
}

--- FIN DE ARCHIVO: ui/components/Mapa.qml ---

--- INICIO DE ARCHIVO: ui/components/BarraInferior.qml ---
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts

ToolBar {
    id: root
    height: 60
    background: Rectangle { color: "#1e1e2e" }

    // ========================================================
    // PROPIEDADES 
    // ========================================================
    property string dia: "1"
    property int paisesInfectados: 1
    property string noticiaActual: "Se reporta una misteriosa enfermedad respiratoria."

    property real sanos: 7800000000 
    property real infectados: 1
    property real recuperados: 0
    property real muertos: 0
    property string primerPaisNombre: "..."

    // ========================================================
    // COMPONENTE DATO CORREGIDO (Sin conflictos de anclaje)
    // ========================================================
    component DatoSird: Item {
        id: datoControl
        property string icono: ""
        property string valor: ""
        property color colorAcento: "white"
        property string tooltipText: "" 

        // El tama√±o del Item se ajusta autom√°ticamente al tama√±o del texto
        implicitWidth: contentRow.implicitWidth
        implicitHeight: contentRow.implicitHeight

        // 1. La fila que acomoda el icono y el texto
        Row {
            id: contentRow
            spacing: 5
            anchors.verticalCenter: parent.verticalCenter

            Text { text: datoControl.icono; color: datoControl.colorAcento; font.pixelSize: 18; font.bold: true }
            Text { text: datoControl.valor; color: "white"; font.pixelSize: 16; font.bold: true }
        }

        // 2. El √°rea t√°ctil que cubre TODO el componente, independiente de la fila
        MouseArea {
            id: mouseArea
            anchors.fill: parent
            hoverEnabled: true

            ToolTip {
                id: infoTooltip
                visible: mouseArea.containsMouse
                text: datoControl.tooltipText
                delay: 150
                x: mouseArea.mouseX
                y: mouseArea.mouseY - height - 10 

                background: Rectangle {
                    color: "#2f3542"
                    radius: 4
                    border.color: "#747d8c"
                }
                contentItem: Text {
                    text: infoTooltip.text
                    color: "white"
                    font.pixelSize: 12
                }
            }
        }
    }

    // ========================================================
    // DISTRIBUCI√ìN DE LA BARRA
    // ========================================================
    RowLayout {
        anchors.fill: parent
        anchors.leftMargin: 20
        anchors.rightMargin: 10
        spacing: 20

        Row {
            Layout.alignment: Qt.AlignVCenter
            spacing: 25

            DatoSird { 
                icono: "üìÖ D√≠a:"; 
                valor: root.dia; 
                colorAcento: "white"
                tooltipText: "D√≠as transcurridos desde el paciente cero"
            }
            DatoSird { 
                icono: "üßç"; 
                valor: Number(root.sanos).toLocaleString(Qt.locale(), 'f', 0); 
                colorAcento: "#DCE775"
                tooltipText: "Poblaci√≥n Sana (Susceptible)"
            }
            DatoSird { 
                icono: "ü§í"; 
                valor: Number(root.infectados).toLocaleString(Qt.locale(), 'f', 0); 
                colorAcento: "#ffb8b8"
                tooltipText: "Personas Infectadas actualmente"
            }
            DatoSird { 
                icono: "üíö"; 
                valor: Number(root.recuperados).toLocaleString(Qt.locale(), 'f', 0); 
                colorAcento: "#4fc3f7"
                tooltipText: "Personas Recuperadas (Inmunes)"
            }
            DatoSird { 
                icono: "üíÄ"; 
                valor: Number(root.muertos).toLocaleString(Qt.locale(), 'f', 0); 
                colorAcento: "#747d8c"
                tooltipText: "Muertes confirmadas"
            }
            DatoSird { 
                icono: "üåç"; 
                valor: root.paisesInfectados + "/250"; 
                colorAcento: "#ffb74d" 
                tooltipText: "Pa√≠ses con al menos un infectado"
            }
            DatoSird { 
                icono: "‚ò£Ô∏è Origen:"; 
                valor: root.primerPaisNombre; 
                colorAcento: "#ff5252" // Rojo alerta
                tooltipText: "Pa√≠s Paciente Cero"
            }
        }

        Item { Layout.fillWidth: true }

        // --- SECCI√ìN DE NOTICIAS ---
        Rectangle {
            Layout.preferredWidth: 350
            Layout.preferredHeight: 40
            Layout.alignment: Qt.AlignVCenter
            color: "#2f3542"
            radius: 5
            border.color: "#747d8c"
            clip: true 

            RowLayout {
                anchors.fill: parent
                anchors.margins: 10
                spacing: 10

                Rectangle {
                    Layout.preferredWidth: 80
                    Layout.preferredHeight: 20
                    color: "#ff3f34"
                    radius: 3
                    Text { 
                        anchors.centerIn: parent; text: "NOTICIA"; 
                        color: "white"; font.pixelSize: 10; font.bold: true 
                    }
                }

                Text {
                    Layout.fillWidth: true
                    text: root.noticiaActual
                    color: "white"
                    font.pixelSize: 13
                    font.italic: true
                    elide: Text.ElideRight 
                }
            }
        }
    }
}

--- FIN DE ARCHIVO: ui/components/BarraInferior.qml ---

--- INICIO DE ARCHIVO: ui/components/BarraSuperior.qml ---
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts

ToolBar {
    id: root
    height: 60
    background: Rectangle { color: "#1e1e2e" }

    // --- SE√ëALES PARA COMUNICARSE CON EL EXTERIOR ---
    signal menuClicked()
    signal playPauseClicked(bool isPlaying)
    signal resetClicked()

    // Bot√≥n Men√∫ (Izquierda)
    ToolButton {
        id: menuButton
        text: "‚ò∞"
        font.pixelSize: 24
        anchors.left: parent.left
        anchors.verticalCenter: parent.verticalCenter
        anchors.leftMargin: 10
        // Al hacer clic, emite la se√±al
        onClicked: root.menuClicked() 
    }

    // Botones de Simulaci√≥n (Centrados)
    Row {
        anchors.centerIn: parent
        spacing: 15

        RoundButton {
            id: playPauseButton
            property bool isPlaying: false
            width: 45; height: 45
            
            background: Rectangle {
                color: playPauseButton.isPlaying ? "#ffb8b8" : "#DCE775"
                radius: width / 2 
            }
            contentItem: Text {
                text: playPauseButton.isPlaying ? "‚è∏" : "‚ñ∂" 
                color: "#121212"
                font.pixelSize: 20
                horizontalAlignment: Text.AlignHCenter
                verticalAlignment: Text.AlignVCenter
            }

            onClicked: {
                isPlaying = !isPlaying
                root.playPauseClicked(isPlaying) // Emite la se√±al
            }
        }

        RoundButton {
            id: resetButton
            width: 45; height: 45
            
            background: Rectangle { color: "#747d8c"; radius: width / 2 }
            contentItem: Text {
                text: "‚ü≤"
                color: "white"
                font.pixelSize: 24
                font.bold: true
                horizontalAlignment: Text.AlignHCenter
                verticalAlignment: Text.AlignVCenter
            }

            onClicked: {
                playPauseButton.isPlaying = false
                root.resetClicked() // Emite la se√±al
            }
        }
    }
}

--- FIN DE ARCHIVO: ui/components/BarraSuperior.qml ---

--- INICIO DE ARCHIVO: ui/components/MenuOpciones.qml ---
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Layouts 1.15

Drawer {
    id: rootDrawer
    width: 300
    modal: false
    dim: false
    closePolicy: Popup.NoAutoClose
    background: Rectangle { color: "#1e1e2e" }
    
    // Control de navegaci√≥n interna: 0=Menu, 1=Config, 2=Params, 3=Stats
    property int vistaActual: 0 

    // Al abrir el men√∫, pausamos para ahorrar recursos
    onOpened: if(backend) backend.pausar_simulacion()

    ColumnLayout {
        anchors.fill: parent
        anchors.margins: 20
        spacing: 15

        // CABECERA
        Text {
            text: "Paper-Pandemic"
            color: "#bdc3c7"
            font.bold: true
            font.pixelSize: 24
            Layout.alignment: Qt.AlignHCenter
        }
        
        Rectangle { 
            Layout.fillWidth: true; height: 2; color: "#ff5252" 
        }

        // CONTENIDO CAMBIANTE
        StackLayout {
            id: stackVistas
            currentIndex: rootDrawer.vistaActual
            Layout.fillWidth: true
            Layout.fillHeight: true

            // -----------------------------------------------------
            // √çNDICE 0: MEN√ö PRINCIPAL
            // -----------------------------------------------------
            ColumnLayout {
                spacing: 15
                Text { text: "Men√∫ Principal"; color: "white"; font.pixelSize: 18; Layout.alignment: Qt.AlignHCenter }

                Button {
                    Layout.fillWidth: true; height: 50
                    background: Rectangle { color: "#3a3f55"; radius: 8 }
                    contentItem: Text { text: "üîß Configuraci√≥n"; color: "white"; font.pixelSize: 16; horizontalAlignment: Text.AlignHCenter; verticalAlignment: Text.AlignVCenter }
                    onClicked: rootDrawer.vistaActual = 1
                }

                Button {
                    Layout.fillWidth: true; height: 50
                    background: Rectangle { color: "#3a3f55"; radius: 8 }
                    contentItem: Text { text: "‚öôÔ∏è Par√°metros"; color: "white"; font.pixelSize: 16; horizontalAlignment: Text.AlignHCenter; verticalAlignment: Text.AlignVCenter }
                    onClicked: rootDrawer.vistaActual = 2
                }

                Button {
                    Layout.fillWidth: true; height: 50
                    background: Rectangle { color: "#3a3f55"; radius: 8 }
                    contentItem: Text { text: "üìä Estad√≠sticas"; color: "white"; font.pixelSize: 16; horizontalAlignment: Text.AlignHCenter; verticalAlignment: Text.AlignVCenter }
                    onClicked: rootDrawer.vistaActual = 3
                }

                Item { Layout.fillHeight: true }
            }

            // -----------------------------------------------------
            // √çNDICE 1: CONFIGURACI√ìN
            // -----------------------------------------------------
            ColumnLayout {
                Text { text: "Configuraci√≥n"; color: "white"; font.pixelSize: 18; Layout.alignment: Qt.AlignHCenter }
                
                Text { 
                    text: "Pr√≥ximamente...\nAqu√≠ podr√°s cambiar el idioma,\ntemas de color, etc." 
                    color: "#7f8c8d"; horizontalAlignment: Text.AlignHCenter; Layout.fillWidth: true 
                }
                
                Item { Layout.fillHeight: true }
                
                Button {
                    Layout.fillWidth: true; flat: true
                    contentItem: Text { text: "‚¨Ö Volver"; color: "#ff5252"; font.bold: true; horizontalAlignment: Text.AlignHCenter }
                    onClicked: rootDrawer.vistaActual = 0
                }
            }

            // -----------------------------------------------------
            // √çNDICE 2: PAR√ÅMETROS (SLIDERS)
            // -----------------------------------------------------
            ScrollView {
                clip: true
                ColumnLayout {
                    width: parent.width
                    spacing: 20

                    Text { text: "Ajuste de Variables"; color: "white"; font.pixelSize: 18; Layout.alignment: Qt.AlignHCenter }

                    SliderControl {
                        titulo: "‚è© Velocidad Simulaci√≥n"
                        valorInicial: 0.5; maximo: 2.0
                        onValorCambiado: (val) => { if(backend) backend.cambiar_velocidad(val) }
                    }
                    
                    SliderControl {
                        titulo: "Tasa de Contagio (Œ≤)"
                        valorInicial: backend ? backend.config.beta : 0.5; maximo: 1.0
                        onValorCambiado: (val) => { if(backend) backend.config.beta = val }
                    }

                    SliderControl {
                        titulo: "Recuperaci√≥n (Œ≥)"
                        valorInicial: backend ? backend.config.gamma : 0.1; maximo: 0.5
                        onValorCambiado: (val) => { if(backend) backend.config.gamma = val }
                    }

                    SliderControl {
                        titulo: "Mortalidad (Œº)"
                        valorInicial: backend ? backend.config.mu : 0.01; maximo: 0.1
                        onValorCambiado: (val) => { if(backend) backend.config.mu = val }
                    }

                    SliderControl {
                        titulo: "Prob. Frontera"
                        valorInicial: backend ? backend.config.p_frontera : 1.0; maximo: 1.0
                        onValorCambiado: (val) => { if(backend) backend.config.p_frontera = val }
                    }

                    Item { Layout.fillHeight: true; height: 20 }

                    Button {
                        Layout.fillWidth: true; height: 50
                        background: Rectangle { color: "#e74c3c"; radius: 8 }
                        contentItem: Text { text: "‚ö†Ô∏è APLICAR Y REINICIAR"; color: "white"; font.bold: true; horizontalAlignment: Text.AlignHCenter; verticalAlignment: Text.AlignVCenter }
                        onClicked: {
                            if(backend) backend.reiniciar_simulacion()
                            // Nos quedamos aqu√≠ para ver el cambio
                        }
                    }

                    Button {
                        Layout.fillWidth: true; flat: true
                        contentItem: Text { text: "‚¨Ö Volver al Men√∫"; color: "#b2bec3"; horizontalAlignment: Text.AlignHCenter }
                        onClicked: rootDrawer.vistaActual = 0
                    }
                }
            }

            // -----------------------------------------------------
            // √çNDICE 3: ESTAD√çSTICAS
            // -----------------------------------------------------
            ColumnLayout {
                Text { text: "Estad√≠sticas"; color: "white"; font.pixelSize: 18; Layout.alignment: Qt.AlignHCenter }
                
                Item { Layout.fillHeight: true; height: 20 }

                Button {
                    Layout.fillWidth: true; height: 60
                    background: Rectangle { 
                        color: "#e67e22" // Naranja (Diferente al verde de la gr√°fica)
                        radius: 8 
                    }
                    contentItem: RowLayout {
                        anchors.centerIn: parent
                        Text { text: "üèÜ"; font.pixelSize: 24 }
                        Text { text: "Ranking de Pa√≠ses"; color: "white"; font.bold: true; font.pixelSize: 16 }
                    }
                    
                    onClicked: {
                        if(backend) backend.pausar_simulacion()
                        mainWindow.vistaActual = "ranking" // Cambiamos a la nueva vista
                        rootDrawer.close()
                    }
                }

                // BOT√ìN: VER CURVA HIST√ìRICA
                Button {
                    Layout.fillWidth: true; height: 60
                    background: Rectangle { 
                        color: "#2ecc71" 
                        radius: 8 
                    }
                    contentItem: RowLayout {
                        anchors.centerIn: parent
                        Text { text: "üìà"; font.pixelSize: 24 }
                        Text { text: "Ver Curva Hist√≥rica"; color: "white"; font.bold: true; font.pixelSize: 16 }
                    }
                    
                    onClicked: {
                        if(backend) backend.pausar_simulacion()
                        
                        // Cambiamos la vista principal en main.qml
                        mainWindow.vistaActual = "grafico"
                        
                        // Cerramos el men√∫
                        rootDrawer.close()
                    }
                }

                Text { 
                    text: "El mapa se cerrar√° temporalmente\npara optimizar el rendimiento." 
                    color: "#7f8c8d"; font.italic: true; horizontalAlignment: Text.AlignHCenter; Layout.fillWidth: true 
                }
                
                Item { Layout.fillHeight: true }
                
                Button {
                    Layout.fillWidth: true; flat: true
                    contentItem: Text { text: "‚¨Ö Volver"; color: "#ff5252"; font.bold: true; horizontalAlignment: Text.AlignHCenter }
                    onClicked: rootDrawer.vistaActual = 0
                }
            }
        }
    }

    // COMPONENTE SLIDER REUTILIZABLE
    component SliderControl : ColumnLayout {
        property string titulo: ""
        property real valorInicial: 0
        property real maximo: 1.0
        signal valorCambiado(real val)

        Layout.fillWidth: true
        spacing: 5
        RowLayout {
            Layout.fillWidth: true
            Text { text: titulo; color: "#bdc3c7"; font.bold: true; Layout.fillWidth: true }
            Text { text: slider.value.toFixed(3); color: "#00cec9"; font.bold: true }
        }
        Slider {
            id: slider
            Layout.fillWidth: true
            from: 0.0; to: maximo; value: valorInicial; stepSize: 0.001
            onMoved: parent.valorCambiado(value) // Actualizaci√≥n en tiempo real
        }
    }
}

--- FIN DE ARCHIVO: ui/components/MenuOpciones.qml ---

